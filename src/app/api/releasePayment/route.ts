import { db } from "@/lib/db";
import { getUserByAuthHeader, getAccessToken } from "@/lib/apiUtils";
import { NextRequest, NextResponse } from "next/server";
import { Connection, Keypair, PublicKey, SystemProgram, Transaction } from "@solana/web3.js";
import { AnchorProvider, Program, BN } from "@coral-xyz/anchor";
import { getAssociatedTokenAddress, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID, createAssociatedTokenAccountInstruction } from "@solana/spl-token";
import { getAssociatedTokenAddressSync } from "@solana/spl-token";
import { bs58 } from "@coral-xyz/anchor/dist/cjs/utils/bytes";
import { createHash } from "crypto";
import { OctasolContract } from "../../../../contract/types/octasol_contract";
import idl from "../../../../contract/idl/octasol_contract.json";
import NodeWallet from '@coral-xyz/anchor/dist/cjs/nodewallet';
import { generateBountyKeypair } from "@/lib/utils";
import { isAdmin } from "@/lib/constants";
import { getInstallationId } from "@/utils/dbUtils";
import axios from "axios";

// Helper function to post GitHub comment on PR
async function postGitHubComment(bountyId: number, txSignature: string, isCustomPayout: boolean = false) {
  try {
    // Get bounty details to find the PR
    const bounty = await db.bounty.findUnique({
      where: { id: bountyId },
      include: {
        sponsor: true,
        submissions: {
          where: { status: 4 }, // Get the winning submission
          take: 1
        }
      }
    });

    if (!bounty || !bounty.issueNumber || !bounty.repoName || !bounty.sponsor?.githubId) {
      console.log('No issue number, repo, or sponsor found for bounty:', bountyId);
      return;
    }

    // Validate issue number is positive
    if (bounty.issueNumber <= 0) {
      console.log('Invalid issue number for bounty:', bountyId, 'Issue number:', bounty.issueNumber);
      return;
    }

    // Get installation ID for the sponsor's GitHub ID
    const installationId = await getInstallationId(bounty.sponsor.githubId);
    if (!installationId) {
      console.log('No installation ID found for sponsor:', bounty.sponsor.githubId);
      return;
    }

    // Get access token
    const accessToken = await getAccessToken(Number(installationId));
    if (!accessToken) {
      console.log('Failed to get access token for installation:', installationId);
      return;
    }

    // Extract owner and repo from repoName
    const [owner, repo] = bounty.repoName.split('/');
    if (!owner || !repo) {
      console.log('Invalid repo name format:', bounty.repoName);
      return;
    }

    // Get winner submission details for more comprehensive comment
    const winnerSubmission = bounty.submissions[0];
    let winnerUsername = null;
    let maskedWalletAddress = null;

    if (winnerSubmission) {
      try {
        const winnerUser = await db.user.findUnique({
          where: { githubId: winnerSubmission.githubId },
          select: { githubUsername: true }
        });
        winnerUsername = winnerUser?.githubUsername;
      } catch (error) {
        console.log('Failed to fetch winner username:', error);
      }
      // Mask wallet address: show only first 3 and last 4, else 'Not provided'
      if (winnerSubmission.walletAddress && winnerSubmission.walletAddress.length >= 8) {
        maskedWalletAddress = `${winnerSubmission.walletAddress.slice(0, 3)}...${winnerSubmission.walletAddress.slice(-4)}`;
      } else if (winnerSubmission.walletAddress) {
        maskedWalletAddress = `${winnerSubmission.walletAddress.slice(0, 1)}...${winnerSubmission.walletAddress.slice(-1)}`;
      } else {
        maskedWalletAddress = 'Not provided';
      }
    }

    // Create comprehensive comment content
    let commentContent = '';
    
    if (isCustomPayout) {
      commentContent = `## Bounty Payment Released

**Bounty:** ${bounty.bountyname}
**Status:** Payment Completed
**Transaction Hash:** \`${txSignature}\`

This bounty has been successfully paid out to a custom wallet address by the admin of Octasol.

**Payment Details:**
- **Amount:** ${bounty.price} USDC
- **Payment Method:** Custom Wallet Address

**Next Steps:**
- The payment has been processed and should appear in the specified wallet address
- You can verify the transaction on [Solana Explorer](https://explorer.solana.com/tx/${txSignature}?cluster=${process.env.NEXT_PUBLIC_SOLANA_CLUSTER})
- For any issues, please contact the bounty sponsor or Octasol support

---
*This comment was automatically generated by the Octasol platform.*`;
    } else {
      commentContent = `## Bounty Payment Released

**Bounty:** ${bounty.bountyname}
**Status:** Payment Completed
**Transaction Hash:** \`${txSignature}\`

Congratulations! This bounty has been successfully paid out to the winning contributor by the admin of Octasol.

**Payment Details:**
- **Amount:** ${bounty.price} USDC
- **Recipient:** ${winnerUsername || 'Contributor'}
- **Payment Method:** Direct Transfer

**Contributor Information:**
${winnerSubmission ? `- **GitHub:** @${winnerUsername || 'Unknown'}
- **Wallet Address:** \`${maskedWalletAddress}\`` : '- Contributor details not available'}

**Next Steps:**
- The payment has been processed and should appear in the contributor's wallet
- You can verify the transaction on [Solana Explorer](https://explorer.solana.com/tx/${txSignature}?cluster=${process.env.NEXT_PUBLIC_SOLANA_CLUSTER})
- For any issues, please contact the bounty sponsor or Octasol support

---
*This comment was automatically generated by the Octasol platform.*`;
    }

    // Post comment to GitHub PR
    const response = await axios.post(
      `https://api.github.com/repos/${owner}/${repo}/issues/${bounty.issueNumber}/comments`,
      {
        body: commentContent
      },
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Accept': 'application/vnd.github.v3+json',
          'User-Agent': 'Octasol-Bot'
        }
      }
    );

  } catch (error) {
    console.error('Failed to post GitHub comment:', error);
    // Don't throw error - commenting is not critical for payment
  }
}

export async function POST(req: NextRequest) {
  try {
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      return NextResponse.json(
        { error: "Authorization header is required" },
        { status: 401 }
      );
    }

    const user = await getUserByAuthHeader(authHeader);
    if (!user) {
      return NextResponse.json(
        { error: "Invalid Authorization Header" },
        { status: 401 }
      );
    }

    // Check if user is admin
    const adminStatus = await isAdmin(user.login);

    if (!adminStatus) {
      return NextResponse.json(
        { error: "Access denied. Admin privileges required." },
        { status: 403 }
      );
    }

    const { bountyId, submissionId, transactionHash, customWalletAddress, isCustomPayout, isAdminPayout } = await req.json();
    if (!bountyId) {
      return NextResponse.json(
        { error: "Bounty ID is required" },
        { status: 400 }
      );
    }

    if (!isCustomPayout && !isAdminPayout && (!submissionId || !transactionHash)) {
      return NextResponse.json(
        { error: "Submission ID and transaction hash are required for regular payouts" },
        { status: 400 }
      );
    }


    if (isAdminPayout && !submissionId) {
      return NextResponse.json(
        { error: "Submission ID is required for admin payouts" },
        { status: 400 }
      );
    }

    let updatedSubmission: any = null;
    let updatedBounty: any;
    let lastTxSignature: string | undefined;

    if (isCustomPayout) {
      // Custom payout - execute blockchain transaction on server using adminAssignAndRelease
      try {
        const SERVER_WALLET_SECRET_KEY = process.env.ADMIN_PRIVATE_KEY;
        if (!SERVER_WALLET_SECRET_KEY) {
          throw new Error('ADMIN_PRIVATE_KEY environment variable is not set.');
        }
        const privateKeyBuffer = bs58.decode(SERVER_WALLET_SECRET_KEY);
        const serverKeypair = Keypair.fromSecretKey(privateKeyBuffer);
        const serverWallet = new NodeWallet(serverKeypair);

        // Create the connection object
        const connection = new Connection(
          process.env.SOLANA_RPC_URL || 'https://api.devnet.solana.com',
          'confirmed'
        );

        // Create the Anchor Provider with the server's wallet and the connection
        const provider = new AnchorProvider(connection, serverWallet, {
          preflightCommitment: 'confirmed',
          commitment: 'confirmed',
        });

        // Create the Program object
        const program = new Program(idl as OctasolContract, provider);

        const bountyAccountKp = generateBountyKeypair(bountyId.toString());
        const [escrowAuthorityPda] = PublicKey.findProgramAddressSync(
          [Buffer.from("escrow_auth"), bountyAccountKp.publicKey.toBuffer()],
          program.programId
        );

        const USDCMintAddress = process.env.NEXT_PUBLIC_USDC_MINT_ADDRESS || "";
        const USDCMint = new PublicKey(USDCMintAddress);
        const contributorAccount = new PublicKey(customWalletAddress);
        const bountyIdBN = new BN(bountyId);

        const contributorTokenAccount = getAssociatedTokenAddressSync(
          USDCMint,
          contributorAccount,
          false,
          TOKEN_PROGRAM_ID
        );

        const escrowTokenAccount = await getAssociatedTokenAddress(
          USDCMint,
          escrowAuthorityPda,
          true // PDA-owned account
        );

        // Check if contributor token account exists, create if not
        try {
          await connection.getTokenAccountBalance(contributorTokenAccount);
        } catch (error) {
          // Token account doesn't exist, create it
          const createATAInstruction = createAssociatedTokenAccountInstruction(
            serverWallet.publicKey, // payer
            contributorTokenAccount, // ata
            contributorAccount, // owner
            USDCMint // mint
          );

          const createATATx = new Transaction().add(createATAInstruction);
          await provider.sendAndConfirm(createATATx);
        }

        // Derive config PDA and fetch on-chain bounty to get maintainer
        const [configPda] = PublicKey.findProgramAddressSync(
          [Buffer.from("config")],
          program.programId
        );

        const onchainBounty: any = await (program as any).account.bounty.fetch(bountyAccountKp.publicKey);

        // Get bounty price from database
        const bounty = await db.bounty.findUnique({
          where: { id: bountyId },
          select: { price: true }
        });

        if (!bounty) {
          throw new Error('Bounty not found');
        }


    const config: any = await (program as any).account.configState.fetch(configPda);
    const validAdmin = serverWallet.publicKey.equals(config.admin);
    if (!validAdmin) {
      throw new Error('Invalid admin');
    }
        // Execute the smart contract transaction with admin-only instruction
        const txSignature = await program.methods
          .adminAssignAndRelease(bountyIdBN)
          .accounts({
            admin: serverWallet.publicKey,
            config: configPda,
            bounty: bountyAccountKp.publicKey,
            escrowAuthority: escrowAuthorityPda,
            maintainer: onchainBounty.maintainer,
            contributor: contributorAccount,
            contributorTokenAccount: contributorTokenAccount,
            escrowTokenAccount: escrowTokenAccount,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
            associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
          })
          .rpc();

        // Wait for transaction confirmation
        const confirmation = await connection.confirmTransaction(txSignature, 'confirmed');

        if (confirmation.value.err) {
          throw new Error(`Transaction failed: ${confirmation.value.err}`);
        }

        // Update database after successful transaction
        updatedBounty = await db.bounty.update({
          where: { id: bountyId },
          data: { 
            status: 3, // Completed
            transactionHash: txSignature
          }
        });
        lastTxSignature = txSignature;

        // Reject all submissions for this bounty since it was paid to a custom wallet
        await db.submission.updateMany({
          where: { bountyId: bountyId },
          data: { status: 3 } // Rejected
        });

        // Post GitHub comment about payment
        await postGitHubComment(bountyId, txSignature, true);

      } catch (error) {
        console.error('Failed to execute custom payout transaction:', error);
        return NextResponse.json(
          { error: "Failed to execute blockchain transaction" },
          { status: 500 }
        );
      }
    } else if (isAdminPayout) {
      // Admin payout - execute blockchain transaction on server (unchanged)
      try {
        const SERVER_WALLET_SECRET_KEY = process.env.ADMIN_PRIVATE_KEY;
        if (!SERVER_WALLET_SECRET_KEY) {
          throw new Error('ADMIN_PRIVATE_KEY environment variable is not set.');
        }
        const privateKeyBuffer = bs58.decode(SERVER_WALLET_SECRET_KEY);
        const serverKeypair = Keypair.fromSecretKey(privateKeyBuffer);
        const serverWallet = new NodeWallet(serverKeypair);

        // Create the connection object
        const connection = new Connection(
          process.env.SOLANA_RPC_URL || 'https://api.devnet.solana.com',
          'confirmed'
        );

        // Create the Anchor Provider with the server's wallet and the connection
        const provider = new AnchorProvider(connection, serverWallet, {
          preflightCommitment: 'confirmed',
          commitment: 'confirmed',
        });

        // Create the Program object
        const program = new Program(idl as OctasolContract, provider);

        // Get the submission details
        const submission = await db.submission.findUnique({
          where: { id: submissionId },
          include: { bounty: true }
        });

        if (!submission) {
          throw new Error('Submission not found');
        }

        if (!submission.walletAddress) {
          throw new Error('Submission has no wallet address');
        }

        const bountyAccountKp = generateBountyKeypair(submission.bountyId.toString());
        const [escrowAuthorityPda] = PublicKey.findProgramAddressSync(
          [Buffer.from("escrow_auth"), bountyAccountKp.publicKey.toBuffer()],
          program.programId
        );

        const USDCMintAddress = process.env.NEXT_PUBLIC_USDC_MINT_ADDRESS || "";
        const USDCMint = new PublicKey(USDCMintAddress);
        const winnerAccount = new PublicKey(submission.walletAddress);
        const bountyIdBN = new BN(submission.bountyId);
        const [configPdaAdmin] = PublicKey.findProgramAddressSync(
          [Buffer.from("config")],
          program.programId
        );
        const config: any = await (program as any).account.configState.fetch(configPdaAdmin);

        const contributorTokenAccount = getAssociatedTokenAddressSync(
          USDCMint,
          winnerAccount,
          false,
          TOKEN_PROGRAM_ID
        );

        const escrowTokenAccount = await getAssociatedTokenAddress(
          USDCMint,
          escrowAuthorityPda,
          true // PDA-owned account
        );

        // Check if contributor token account exists, create if not
        try {
          await connection.getTokenAccountBalance(contributorTokenAccount);
        } catch (error) {
          // Token account doesn't exist, create it
          const createATAInstruction = createAssociatedTokenAccountInstruction(
            serverWallet.publicKey, // payer
            contributorTokenAccount, // ata
            winnerAccount, // owner
            USDCMint // mint
          );

          const createATATx = new Transaction().add(createATAInstruction);
          await provider.sendAndConfirm(createATATx);
        }
        const configPda = PublicKey.findProgramAddressSync([Buffer.from("config")], program.programId);

        const validAdmin = serverWallet.publicKey.equals(config.admin);
        if (!validAdmin) {
          throw new Error('Invalid admin');
        }

        // Execute the smart contract transaction (same as webhook releasePayment)
        const txSignature = await program.methods
          .completeBounty(bountyIdBN)
          .accounts({
            bounty: bountyAccountKp.publicKey,
            escrowAuthority: escrowAuthorityPda,
            maintainer: serverWallet.publicKey,
            contributor: winnerAccount,
            contributorTokenAccount: contributorTokenAccount,
            escrowTokenAccount: escrowTokenAccount,
            systemProgram: SystemProgram.programId,
            tokenProgram: TOKEN_PROGRAM_ID,
            associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
            admin: serverWallet.publicKey,
            config: configPda,
          })
          .rpc();

        // Wait for transaction confirmation
        const confirmation = await connection.confirmTransaction(txSignature, 'confirmed');

        if (confirmation.value.err) {
          throw new Error(`Transaction failed: ${confirmation.value.err}`);
        }

        // Update database after successful transaction
        updatedSubmission = await db.submission.update({
          where: { id: submissionId },
          data: { status: 4 } // Paid out
        });

        updatedBounty = await db.bounty.update({
          where: { id: bountyId },
          data: { 
            status: 3, // Completed
            transactionHash: txSignature
          }
        });
        lastTxSignature = txSignature;

        // Reject all other submissions for this bounty
        await db.submission.updateMany({
          where: { 
            bountyId: bountyId,
            id: { not: submissionId }
          },
          data: { status: 3 } // Rejected
        });

        // Post GitHub comment about payment
        await postGitHubComment(bountyId, txSignature, false);

      } catch (error) {
        console.error('Failed to execute admin payout transaction:', error);
        return NextResponse.json(
          { error: "Failed to execute blockchain transaction" },
          { status: 500 }
        );
      }
    } else {
      // Regular payout - update the specific submission
      updatedSubmission = await db.submission.update({
        where: { id: submissionId },
        data: { status: 4 } // Paid out
      });

      // Update the bounty with transaction hash and mark as completed
      updatedBounty = await db.bounty.update({
        where: { id: bountyId },
        data: { 
          status: 3, // Completed
          transactionHash: transactionHash
        }
      });

      // Reject all other submissions for this bounty
      await db.submission.updateMany({
        where: { 
          bountyId: bountyId,
          id: { not: submissionId }
        },
        data: { status: 3 } // Rejected
      });

      // Post GitHub comment about payment
      await postGitHubComment(bountyId, transactionHash, false);
    }

    const responseData = {
      submission: updatedSubmission
        ? { id: updatedSubmission.id, status: updatedSubmission.status }
        : null,
      bounty: updatedBounty
        ? { id: updatedBounty.id, status: updatedBounty.status, transactionHash: updatedBounty.transactionHash }
        : null,
      txSignature: lastTxSignature,
    };

    return NextResponse.json({
      success: true,
      message: "Payment released successfully",
      data: responseData,
    });

  } catch (error) {
    console.error("Error releasing payment:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
